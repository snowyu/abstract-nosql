// Generated by CoffeeScript 1.12.7
(function() {
  var AbstractChainedBatch, AbstractError, AbstractIterator, AbstractNoSQL, AbstractObject, CloseError, Codec, Errors, InvalidArgumentError, NotImplementedError, OpenError, inherits, isArray, isFunction, isString, setImmediate, utf8ByteLength, xtend;

  xtend = require("xtend");

  AbstractObject = require("abstract-object");

  Codec = require("buffer-codec");

  utf8ByteLength = Codec.getByteLen;

  Errors = require("./abstract-error");

  try {
    AbstractIterator = require("abstract-iterator");
  } catch (error) {}

  AbstractChainedBatch = require("./abstract-chained-batch");

  setImmediate = global.setImmediate || process.nextTick;

  AbstractError = Errors.AbstractError;

  NotImplementedError = Errors.NotImplementedError;

  InvalidArgumentError = Errors.InvalidArgumentError;

  OpenError = Errors.OpenError;

  CloseError = Errors.CloseError;

  inherits = require("inherits-ex/lib/inherits");

  isString = require("util-ex/lib/is/type/string");

  isFunction = require("util-ex/lib/is/type/function");

  isArray = require("util-ex/lib/is/type/array");

  module.exports = AbstractNoSQL = (function() {
    inherits(AbstractNoSQL, AbstractObject);

    function AbstractNoSQL() {
      AbstractNoSQL.__super__.constructor.apply(this, arguments);
    }

    AbstractNoSQL.prototype.initialize = function(location) {
      if (location && typeof location !== "string") {
        throw new InvalidArgumentError("constructor requires a location string argument");
      }
      return this.location = location;
    };

    AbstractNoSQL.prototype.finalize = function() {
      if (this._opened) {
        if (this._closeSync) {
          this.closeSync();
        } else {
          this.closeAsync();
        }
      }
      return this._options = null;
    };

    AbstractNoSQL.prototype.__defineGetter__("opened", function() {
      return !!this._opened;
    });

    AbstractNoSQL.prototype.setOpened = function(aValue, options) {
      if (aValue) {
        this._opened = true;
        if (options) {
          return this._options = options;
        }
      } else {
        return this._opened = false;
      }
    };

    AbstractNoSQL.prototype.isExistsSync = function(key, options) {
      var err, result;
      if (options == null) {
        options = {};
      }
      if (!this._isBuffer(key)) {
        key = String(key);
      }
      if (this._isExistsSync) {
        result = this._isExistsSync(key, options);
        return result;
      } else if (this._getSync) {
        try {
          this._getSync(key, options);
          return true;
        } catch (error) {
          err = error;
          if (AbstractError.isNotFound(err)) {
            return false;
          } else {
            throw err;
          }
        }
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.isExistSync = AbstractNoSQL.prototype.isExistsSync;

    AbstractNoSQL.prototype.getSync = function(key, options) {
      var err, result;
      if (this._getSync) {
        if (options == null) {
          options = {};
        }
        if (err = this._checkKey(key, "key")) {
          throw err;
        }
        if (!this._isBuffer(key)) {
          key = String(key);
        }
        result = this._getSync(key, options);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.getBufferSync = function(key, destBuffer, options) {
      var result;
      if (this._getBufferSync) {
        if (options == null) {
          options = {};
        }
        if (options.offset == null) {
          options.offset = 0;
        }
        result = this._getBufferSync(key, destBuffer, options);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.mGetSync = function(keys, options) {
      var arr, i, needKeyName, result;
      if (this._mGetSync) {
        if (options == null) {
          options = {};
        }
        options.raiseError = options.raiseError !== false;
        needKeyName = options.keys;
        arr = this._mGetSync(keys, options);
        i = 0;
        result = [];
        while (i < arr.length) {
          if (needKeyName !== false) {
            result.push({
              key: arr[i],
              value: arr[++i]
            });
          } else {
            result.push(arr[i]);
          }
          i++;
        }
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.putSync = function(key, value, options) {
      var result;
      if (this._putSync) {
        if (options == null) {
          options = {};
        }
        result = this._putSync(key, value, options);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.delSync = function(key, options) {
      var result;
      if (this._delSync) {
        if (options == null) {
          options = {};
        }
        result = this._delSync(key, options);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.batchSync = function(operations, options) {
      var e, err, j, len, result;
      if (this._batchSync) {
        if (options == null) {
          options = {};
        }
        if (!isArray(operations)) {
          throw new InvalidArgumentError("batch(operations) requires an array argument");
        }
        for (j = 0, len = operations.length; j < len; j++) {
          e = operations[j];
          if (typeof e !== "object") {
            continue;
          }
          if (err = this._checkKey(e.type, "type")) {
            throw err;
          }
          if (err = this._checkKey(e.key, "key")) {
            throw err;
          }
        }
        result = this._batchSync(operations, options);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.approximateSizeSync = function(start, end) {
      var result;
      if (this._approximateSizeSync) {
        if ((start == null) || (end == null)) {
          throw new InvalidArgumentError("approximateSize() requires valid `start`, `end` arguments");
        }
        if (!this._isBuffer(start)) {
          start = String(start);
        }
        if (!this._isBuffer(end)) {
          end = String(end);
        }
        result = this._approximateSizeSync(start, end);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.openSync = function(options) {
      var result;
      if (this._openSync) {
        if (options == null) {
          options = this._options || {};
        }
        options.createIfMissing = options.createIfMissing !== false;
        options.errorIfExists = !!options.errorIfExists;
        result = this._openSync(options);
        if (result) {
          this.setOpened(true, options);
        }
        if (result) {
          result = this;
        }
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.closeSync = function() {
      var result;
      if (this._closeSync) {
        result = this._closeSync();
        if (result) {
          this.setOpened(false);
        }
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype._open = function(options, callback) {
      var that;
      that = this;
      if (this._openSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._openSync(options);
          } catch (error) {
            err = error;
            callback(err);
            return;
          }
          if (result) {
            return callback(null, result);
          } else {
            return callback(new OpenError("can not open database."));
          }
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._close = function(callback) {
      var that;
      that = this;
      if (this._closeSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._closeSync();
          } catch (error) {
            err = error;
            callback(err);
            return;
          }
          if (result) {
            return callback(null, result);
          } else {
            return callback(new CloseError("can not close database."));
          }
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._isExists = function(key, options, callback) {
      var that;
      that = this;
      if (this._isExistsSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._isExistsSync(key, options);
          } catch (error) {
            err = error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return this._get(key, options, function(err, value) {
          if (err) {
            if (AbstractError.isNotFound(err)) {
              return callback(null, false);
            } else {
              return callback(err);
            }
          } else {
            return callback(null, true);
          }
        });
      }
    };

    AbstractNoSQL.prototype._getBuffer = function(key, destBuffer, options, callback) {
      var that;
      that = this;
      if (this._getSync || this._getBufferSync !== AbstractNoSQL.prototype._getBufferSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._getBufferSync(key, destBuffer, options);
          } catch (error) {
            err = error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else if (this._get) {
        return this._get(key, options, function(err, value) {
          var result;
          if (err) {
            return callback(err);
          }
          result = utf8ByteLength(value);
          if (destBuffer) {
            result = Math.min(result, destBuffer.length);
            if (result) {
              result = destBuffer.write(value, options.offset, result);
            }
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._getBufferSync = function(key, destBuffer, options) {
      var result, value;
      if (this._getSync) {
        value = this._getSync(key, options);
        result = utf8ByteLength(value);
        if (destBuffer) {
          result = Math.min(result, destBuffer.length);
          if (result) {
            result = destBuffer.write(value, options.offset, result);
          }
        }
        return result;
      } else {
        throw new NotImplementedError('_mGetSync: _getSync is not implemented.');
      }
    };

    AbstractNoSQL.prototype._mGetSync = function(keys, options) {
      var err, j, key, len, needKeyName, raiseError, result, value;
      if (this._getSync) {
        result = [];
        needKeyName = options.keys;
        raiseError = options.raiseError;
        options.asBuffer = options.asBuffer === true;
        for (j = 0, len = keys.length; j < len; j++) {
          key = keys[j];
          try {
            value = this._getSync(key, options);
          } catch (error) {
            err = error;
            if (raiseError) {
              throw err;
            }
            value = void 0;
          }
          if (needKeyName !== false) {
            result.push(key, value);
          } else {
            result.push(value);
          }
        }
        return result;
      } else {
        throw new NotImplementedError('_mGetSync: _getSync is not implemented.');
      }
    };

    AbstractNoSQL.prototype._mGet = function(keys, options, callback) {
      var i, needKeyName, raiseError, readNext, result, that;
      that = this;
      if (this._getSync || this._mGetSync !== AbstractNoSQL.prototype._mGetSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._mGetSync(keys, options);
          } catch (error) {
            err = error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else if (keys.length > 0 && this._get) {
        result = [];
        i = 0;
        needKeyName = options.keys;
        raiseError = options.raiseError;
        readNext = function(err, value) {
          if (err && raiseError) {
            return callback(err);
          }
          if (needKeyName !== false) {
            result.push(keys[i], value);
          } else {
            result.push(value);
          }
          i++;
          if (i >= keys.length) {
            return callback(null, result);
          }
          return that._get(keys[i], options, readNext);
        };
        return this._get(keys[i], options, readNext);
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._get = function(key, options, callback) {
      var that;
      that = this;
      if (this._getSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._getSync(key, options);
          } catch (error) {
            err = error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._put = function(key, value, options, callback) {
      var that;
      that = this;
      if (this._putSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._putSync(key, value, options);
          } catch (error) {
            err = error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._del = function(key, options, callback) {
      var that;
      that = this;
      if (this._delSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._delSync(key, options);
          } catch (error) {
            err = error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._batch = function(array, options, callback) {
      var that;
      that = this;
      if (this._batchSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._batchSync(array, options);
          } catch (error) {
            err = error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._approximateSize = function(start, end, callback) {
      var that;
      that = this;
      if (this._approximateSizeSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._approximateSizeSync(start, end);
          } catch (error) {
            err = error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype.openAsync = function(options, callback) {
      var that;
      if (options == null) {
        options = {};
      }
      options.createIfMissing = options.createIfMissing !== false;
      options.errorIfExists = !!options.errorIfExists;
      that = this;
      return this._open(options, function(err, result) {
        if (err == null) {
          that.setOpened(true, options);
        }
        return callback(err, result);
      });
    };

    AbstractNoSQL.prototype.open = function(options, callback) {
      if (isFunction(options)) {
        callback = options;
        options = void 0;
      }
      if (callback) {
        return this.openAsync(options, callback);
      } else {
        return this.openSync(options);
      }
    };

    AbstractNoSQL.prototype.closeAsync = function(callback) {
      var that;
      that = this;
      if (!isFunction(callback)) {
        callback = void 0;
      }
      return this._close(function(err, result) {
        if (err) {
          return callback(err);
        }
        that.setOpened(false);
        if (callback) {
          return callback(null, result);
        }
      });
    };

    AbstractNoSQL.prototype.close = function(callback) {
      if (callback) {
        return this.closeAsync(callback);
      } else {
        return this.closeSync();
      }
    };

    AbstractNoSQL.prototype.isExistsAsync = function(key, options, callback) {
      if (options == null) {
        options = {};
      }
      if (!this._isBuffer(key)) {
        key = String(key);
      }
      return this._isExists(key, options, callback);
    };

    AbstractNoSQL.prototype.isExists = function(key, options, callback) {
      if (isFunction(options)) {
        callback = options;
        options = {};
      } else {

      }
      if (callback) {
        return this.isExistsAsync(key, options, callback);
      } else {
        return this.isExistsSync(key, options);
      }
    };

    AbstractNoSQL.prototype.isExist = AbstractNoSQL.prototype.isExists;

    AbstractNoSQL.prototype.getBufferAsync = function(key, destBuffer, options, callback) {
      if (options == null) {
        options = {};
      }
      if (options.offset == null) {
        options.offset = 0;
      }
      return this._getBuffer(key, destBuffer, options, callback);
    };

    AbstractNoSQL.prototype.getBuffer = function(key, destBuffer, options, callback) {
      var err;
      err = void 0;
      if (isFunction(options)) {
        callback = options;
        options = {};
      }
      if (callback) {
        return this.getBufferAsync(key, destBuffer, options, callback);
      } else {
        return this.getBufferSync(key, destBuffer, options);
      }
    };

    AbstractNoSQL.prototype.mGetAsync = function(keys, options, callback) {
      var needKeyName;
      if (options == null) {
        options = {};
      }
      options.asBuffer = options.asBuffer === true;
      options.raiseError = options.raiseError !== false;
      needKeyName = options.keys !== false;
      return this._mGet(keys, options, function(err, arr) {
        var i, result;
        if (err) {
          return callback(err);
        }
        if (needKeyName) {
          i = 0;
          result = [];
          while (i < arr.length) {
            result.push({
              key: arr[i],
              value: arr[++i]
            });
            i++;
          }
        } else {
          result = arr;
        }
        return callback(null, result);
      });
    };

    AbstractNoSQL.prototype.mGet = function(keys, options, callback) {
      var err;
      err = void 0;
      if (isFunction(options)) {
        callback = options;
        options = {};
      } else {

      }
      if (callback) {
        return this.mGetAsync(keys, options, callback);
      } else {
        return this.mGetSync(keys, options);
      }
    };

    AbstractNoSQL.prototype.getAsync = function(key, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (err = this._checkKey(key, "key")) {
        return callback(err);
      }
      if (!this._isBuffer(key)) {
        key = String(key);
      }
      options.asBuffer = options.asBuffer === true;
      return this._get(key, options, callback);
    };

    AbstractNoSQL.prototype.get = function(key, options, callback) {
      var err;
      err = void 0;
      if (isFunction(options)) {
        callback = options;
        options = {};
      }
      if (callback) {
        return this.getAsync(key, options, callback);
      } else {
        return this.getSync(key, options);
      }
    };

    AbstractNoSQL.prototype.putAsync = function(key, value, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (err = this._checkKey(key, "key", this._isBuffer)) {
        return callback(err);
      }
      if (!this._isBuffer(key)) {
        key = String(key);
      }
      if ((value != null) && !this._isBuffer(value) && !process.browser) {
        value = String(value);
      }
      return this._put(key, value, options, callback);
    };

    AbstractNoSQL.prototype.put = function(key, value, options, callback) {
      var err;
      err = void 0;
      if (isFunction(options)) {
        callback = options;
        options = {};
      }
      if (callback) {
        return this.putAsync(key, value, options, callback);
      } else {
        return this.putSync(key, value, options);
      }
    };

    AbstractNoSQL.prototype.delAsync = function(key, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (err = this._checkKey(key, "key", this._isBuffer)) {
        return callback(err);
      }
      if (!this._isBuffer(key)) {
        key = String(key);
      }
      return this._del(key, options, callback);
    };

    AbstractNoSQL.prototype.del = function(key, options, callback) {
      var err;
      err = void 0;
      if (isFunction(options)) {
        callback = options;
        options = {};
      }
      if (callback) {
        return this.delAsync(key, options, callback);
      } else {
        return this.delSync(key, options);
      }
    };

    AbstractNoSQL.prototype.batchAsync = function(array, options, callback) {
      var e, err, j, len, vError;
      if (options == null) {
        options = {};
      }
      if (!isArray(array)) {
        vError = new InvalidArgumentError("batch(array) requires an array argument");
        return callback(vError);
      }
      for (j = 0, len = array.length; j < len; j++) {
        e = array[j];
        if (typeof e !== "object") {
          continue;
        }
        if (err = this._checkKey(e.type, "type")) {
          return callback(err);
        }
        if (err = this._checkKey(e.key, "key")) {
          return callback(err);
        }
      }
      return this._batch(array, options, callback);
    };

    AbstractNoSQL.prototype.batch = function(array, options, callback) {
      if (!arguments.length) {
        return this._chainedBatch();
      }
      if (isFunction(options)) {
        callback = options;
        options = {};
      }
      if (isFunction(array)) {
        callback = array;
      }
      if (callback) {
        return this.batchAsync(array, options, callback);
      } else {
        return this.batchSync(array, options);
      }
    };

    AbstractNoSQL.prototype.approximateSizeAsync = function(start, end, callback) {
      if (!this._isBuffer(start)) {
        start = String(start);
      }
      if (!this._isBuffer(end)) {
        end = String(end);
      }
      return this._approximateSize(start, end, callback);
    };

    AbstractNoSQL.prototype.approximateSize = function(start, end, callback) {
      if ((start == null) || (end == null) || isFunction(start) || isFunction(end)) {
        throw new InvalidArgumentError("approximateSize() requires valid `start`, `end` and `callback`(for async) arguments");
      }
      if (callback) {
        return this.approximateSizeAsync(start, end, callback);
      } else {
        return this.approximateSizeSync(start, end);
      }
    };

    AbstractNoSQL.prototype.IteratorClass = AbstractIterator;

    AbstractNoSQL.prototype.iterator = function(options) {
      if (typeof options !== "object") {
        options = {};
      }
      if (this.IteratorClass) {
        return new this.IteratorClass(this, options);
      } else if (isFunction(this._iterator)) {
        console.error("_iterator is deprecated. please use the IteratorClass instead.");
        return this._iterator(options);
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype._chainedBatch = function() {
      return new AbstractChainedBatch(this);
    };

    AbstractNoSQL.prototype._isBuffer = function(obj) {
      return Buffer.isBuffer(obj);
    };

    AbstractNoSQL.prototype._checkKey = function(obj, type) {
      if (obj == null) {
        return new InvalidArgumentError(type + " cannot be `null` or `undefined`");
      }
      if (this._isBuffer(obj)) {
        if (obj.length === 0) {
          return new InvalidArgumentError(type + " cannot be an empty Buffer");
        }
      } else if (String(obj) === "") {
        return new InvalidArgumentError(type + " cannot be an empty String");
      }
    };

    AbstractNoSQL.prototype.isOpen = function() {
      return !!this._opened;
    };

    return AbstractNoSQL;

  })();

  module.exports.AbstractNoSQL = AbstractNoSQL;

  module.exports.__defineGetter__("AbstractLevelDOWN", function() {
    console.error("AbstractLevelDOWN is deprecated. use AbstractNoSQL instead.");
    return AbstractNoSQL;
  });

  module.exports.__defineGetter__("AbstractIterator", function() {
    console.error("AbstractIterator is deprecated. it's moved to abstract-iterator.");
    if (!AbstractIterator) {
      console.error("first `npm install abstract-iterator`");
    }
    return AbstractIterator;
  });

  module.exports.AbstractChainedBatch = AbstractChainedBatch;

}).call(this);
