// Generated by CoffeeScript 1.12.7
(function() {
  var AbstractError, CloseError, EVENT_DONE, EVENT_STOPPED, Errors, HookedEventError, InvalidArgumentError, NotImplementedError, OpenError, ReadError, WriteError, consts, eventable, extend, filter, isArray, isFunction, isUndefined;

  Errors = require("./abstract-error");

  extend = require('util-ex/lib/_extend');

  isArray = require('util-ex/lib/is/type/array');

  isFunction = require('util-ex/lib/is/type/function');

  isUndefined = require('util-ex/lib/is/type/undefined');

  eventable = require('events-ex/eventable');

  consts = require('events-ex/consts');

  EVENT_DONE = consts.DONE;

  EVENT_STOPPED = consts.STOPPED;

  filter = eventable.filter;

  AbstractError = Errors.AbstractError;

  NotImplementedError = Errors.NotImplementedError;

  InvalidArgumentError = Errors.InvalidArgumentError;

  OpenError = Errors.OpenError;

  CloseError = Errors.CloseError;

  ReadError = Errors.ReadError;

  WriteError = Errors.WriteError;

  HookedEventError = Errors.HookedEventError;

  module.exports = function(aOptions) {
    var vExcludes, vIncludes;
    if (!aOptions) {
      aOptions = {};
    }
    if (!aOptions.methods) {
      aOptions.methods = {};
    }
    vIncludes = aOptions.include;
    if (vIncludes) {
      if (!isArray(vIncludes)) {
        vIncludes = [vIncludes];
      }
    } else {
      vIncludes = [];
    }
    vExcludes = aOptions.exclude;
    if (vExcludes) {
      if (!isArray(vExcludes)) {
        vExcludes = [vExcludes];
      }
    } else {
      vExcludes = [];
    }
    if (!filter('open', vIncludes, vExcludes)) {
      vExcludes.push('openAsync');
      vExcludes.push('openSync');
    }
    if (!filter('close', vIncludes, vExcludes)) {
      vExcludes.push('closeAsync');
      vExcludes.push('closeSync');
    }
    if (!filter('get', vIncludes, vExcludes)) {
      vExcludes.push('getAsync');
      vExcludes.push('getSync');
    }
    if (!filter('getBuffer', vIncludes, vExcludes)) {
      vExcludes.push('getBufferAsync');
      vExcludes.push('getBufferSync');
    }
    if (!filter('mGet', vIncludes, vExcludes)) {
      vExcludes.push('mGetAsync');
      vExcludes.push('mGetSync');
    }
    if (!filter('put', vIncludes, vExcludes)) {
      vExcludes.push('putAsync');
      vExcludes.push('putSync');
    }
    if (!filter('batch', vIncludes, vExcludes)) {
      vExcludes.push('batchAsync');
      vExcludes.push('batchSync');
    }
    if (!filter('del', vIncludes, vExcludes)) {
      vExcludes.push('delAsync');
      vExcludes.push('delSync');
    }
    extend(aOptions.methods, {
      _processHookedResult: function(result) {
        var err, errMsg, vState;
        if (result && (vState = result.state)) {
          if (vState === EVENT_DONE) {
            return result.result;
          } else if (vState === EVENT_STOPPED) {
            errMsg = result.result;
            if (!errMsg) {
              errMsg = 'event stopped by listener';
            }
            err = new HookedEventError(errMsg);
            return err;
          }
        }
      },
      openSync: function(options) {
        var inherited;
        inherited = this["super"];
        return (function(options) {
          var result;
          this.emit('opening', options);
          result = inherited.call(this, options);
          this.emit('ready', result);
          this.emit('open', result);
          if (result) {
            result = this;
          }
          return result;
        }).apply(this.self, arguments);
      },
      openAsync: function(options, callback) {
        var inherited;
        inherited = this["super"];
        return (function(options, callback) {
          this.emit('opening', options);
          return inherited.call(this, options, (function(_this) {
            return function(err, result) {
              if (err) {
                return _this.dispatchError(err, callback);
              }
              _this.emit('ready', result);
              _this.emit('open', result);
              return callback(err, result);
            };
          })(this));
        }).apply(this.self, arguments);
      },
      closeSync: function() {
        var inherited;
        inherited = this["super"];
        return (function() {
          var result;
          this.emit('closing');
          result = inherited.apply(this);
          this.emit('closed', result);
          this.emit('close', result);
          return result;
        }).apply(this.self);
      },
      closeAsync: function(callback) {
        var inherited;
        if (!isFunction(callback)) {
          callback = void 0;
        }
        inherited = this["super"];
        return (function() {
          this.emit('closing');
          return inherited.call(this, (function(_this) {
            return function(err, result) {
              if (err) {
                return _this.dispatchError(err, callback);
              }
              _this.emit('close', result);
              _this.emit('closed', result);
              if (callback) {
                return callback(null, result);
              }
            };
          })(this));
        }).apply(this.self);
      },
      getBufferAsync: function(key, destBuffer, options, callback) {
        var inherited;
        inherited = this["super"];
        return (function(key, destBuffer, options, callback) {
          var result;
          result = this.emit('gettingBuffer', key, destBuffer, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              return this.dispatchError(result, callback);
            } else {
              return callback(null, result);
            }
          }
          return inherited.call(this, key, destBuffer, options, (function(_this) {
            return function(err, result) {
              if (err) {
                return _this.dispatchError(err, callback);
              }
              _this.emit('getBuffer', key, destBuffer, result, options);
              return callback(null, result);
            };
          })(this));
        }).apply(this.self, arguments);
      },
      getBufferSync: function(key, destBuffer, options) {
        var inherited;
        inherited = this["super"];
        return (function(key, destBuffer, options) {
          var result;
          result = this.emit('gettingBuffer', key, destBuffer, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              throw result;
            } else {
              return result;
            }
          }
          result = inherited.apply(this, arguments);
          this.emit('getBuffer', key, destBuffer, result, options);
          return result;
        }).apply(this.self, arguments);
      },
      getAsync: function(key, options, callback) {
        var inherited;
        inherited = this["super"];
        return (function(key, options, callback) {
          var result;
          result = this.emit('getting', key, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              return this.dispatchError(result, callback);
            } else {
              return callback(null, result);
            }
          }
          return inherited.call(this, key, options, (function(_this) {
            return function(err, result) {
              if (err) {
                return _this.dispatchError(err, callback);
              }
              _this.emit('get', key, result, options);
              return callback(null, result);
            };
          })(this));
        }).apply(this.self, arguments);
      },
      getSync: function(key, options) {
        var inherited;
        inherited = this["super"];
        return (function(key, options) {
          var result;
          result = this.emit('getting', key, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              throw result;
            } else {
              return result;
            }
          }
          result = inherited.apply(this, arguments);
          this.emit('get', key, result, options);
          return result;
        }).apply(this.self, arguments);
      },
      mGetAsync: function(key, options, callback) {
        var inherited;
        inherited = this["super"];
        return (function(key, options, callback) {
          var result;
          result = this.emit('mGetting', key, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              return this.dispatchError(result, callback);
            } else {
              return callback(null, result);
            }
          }
          return inherited.call(this, key, options, (function(_this) {
            return function(err, result) {
              if (err) {
                return _this.dispatchError(err, callback);
              }
              _this.emit('mGet', key, result, options);
              return callback(null, result);
            };
          })(this));
        }).apply(this.self, arguments);
      },
      mGetSync: function(key, options) {
        var inherited;
        inherited = this["super"];
        return (function(key, options) {
          var result;
          result = this.emit('mGetting', key, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              throw result;
            } else {
              return result;
            }
          }
          result = inherited.apply(this, arguments);
          this.emit('mGet', key, result, options);
          return result;
        }).apply(this.self, arguments);
      },
      putAsync: function(key, value, options, callback) {
        var inherited;
        inherited = this["super"];
        return (function(key, value, options, callback) {
          var result;
          result = this.emit('putting', key, value, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              return this.dispatchError(result, callback);
            } else {
              return callback(null, result);
            }
          }
          return inherited.call(this, key, value, options, (function(_this) {
            return function(err, result) {
              if (err) {
                return _this.dispatchError(err, callback);
              }
              _this.emit('put', key, value, result, options);
              return callback(null, result);
            };
          })(this));
        }).apply(this.self, arguments);
      },
      putSync: function(key, value, options) {
        var inherited;
        inherited = this["super"];
        return (function(key, value, options) {
          var result;
          result = this.emit('putting', key, value, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              throw result;
            } else {
              return result;
            }
          }
          result = inherited.apply(this, arguments);
          this.emit('put', key, value, result, options);
          return result;
        }).apply(this.self, arguments);
      },
      delAsync: function(key, options, callback) {
        var inherited;
        inherited = this["super"];
        return (function(key, options, callback) {
          var result;
          result = this.emit('deleting', key, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              return this.dispatchError(result, callback);
            } else {
              return callback(null, result);
            }
          }
          return inherited.call(this, key, options, (function(_this) {
            return function(err, result) {
              if (err) {
                return _this.dispatchError(err, callback);
              }
              _this.emit('delete', key, result, options);
              return callback(null, result);
            };
          })(this));
        }).apply(this.self, arguments);
      },
      delSync: function(key, options) {
        var inherited;
        inherited = this["super"];
        return (function(key, options) {
          var result;
          result = this.emit('deleting', key, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              throw result;
            } else {
              return result;
            }
          }
          result = inherited.apply(this, arguments);
          this.emit('delete', key, result, options);
          return result;
        }).apply(this.self, arguments);
      },
      batchAsync: function(operations, options, callback) {
        var inherited;
        inherited = this["super"];
        return (function(operations, options, callback) {
          var result;
          result = this.emit('batching', operations, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              return this.dispatchError(result, callback);
            } else {
              return callback(null, result);
            }
          }
          return inherited.call(this, operations, options, (function(_this) {
            return function(err, result) {
              if (err) {
                return _this.dispatchError(err, callback);
              }
              _this.emit('batch', operations, result, options);
              return callback(null, result);
            };
          })(this));
        }).apply(this.self, arguments);
      },
      batchSync: function(operations, options) {
        var inherited;
        inherited = this["super"];
        return (function(operations, options) {
          var result;
          result = this.emit('batching', operations, options);
          result = this._processHookedResult(result);
          if (!isUndefined(result)) {
            if (result instanceof Error) {
              throw result;
            } else {
              return result;
            }
          }
          result = inherited.apply(this, arguments);
          this.emit('batch', operations, result, options);
          return result;
        }).apply(this.self, arguments);
      }
    });
    return aOptions;
  };

}).call(this);
